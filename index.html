<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Reversi</title>
	</head>
	<body>
		<canvas height=400 width=400 style="background-color:green;"></canvas>
		<div>
			<button id="undo" type="button">Undo</button>
			<button id="reset" type="button">Reset</button>
			<button id="gc" type="button">GC</button>
			<span>User Color:</span><span id="user-color">Black</span>
		</div>
		<script type="text/javascript">
			"use strict"
			// System
			const COLOR = 1, EXIST = 2, STABLE_0 = 4, STABLE_45 = 8,
				STABLE_90 = 16, STABLE_135 = 32, EDGE = 64,
				BLACK = 0, WHITE = 1, STABLE = 60
			var initialBoard = (new Uint8Array([
				0,  0,  0,  0,  0,  0,  0,  0,
				0,  0,  0,  0,  0,  0,  0,  0,
				0,  0, 64, 64, 64, 64,  0,  0,
				0,  0, 64,  3,  2, 64,  0,  0,
				0,  0, 64,  2,  3, 64,  0,  0,
				0,  0, 64, 64, 64, 64,  0,  0,
				0,  0,  0,  0,  0,  0,  0,  0,
				0,  0,  0,  0,  0,  0,  0,  0
			]))
			function GameTree(x, y, color, board) {
				this.x = x
				this.y = y
				this.color = color
				this.board = (new Uint8Array(64))
				this.board.set(board)
				this.list = null
			}
			GameTree.pool = []
			GameTree.log = []
			function getGameTree(x, y, color, board) {
				if (GameTree.pool.length > 0) {
					var gameTree = GameTree.pool.pop()
					gameTree.x = x
					gameTree.y = y
					gameTree.color = color
					gameTree.board.set(board)
					return gameTree
				} else {
					return (new GameTree(x, y, color, board))
				}
			}
			function free(gameTree) {
				if (gameTree.board) {
					if (gameTree.list && gameTree.list.length > 0) {
						gameTree.list.forEach(free)
						gameTree.list.length = 0
					}
					GameTree.pool.push(gameTree)
				}
			}
			function initialGameTree() {
				return getGameTree(8, 8, BLACK, initialBoard)
			}
			function around(func, x, y) {
				func((x - 1), (y - 1))
				func((x - 1), y)
				func((x - 1), (y + 1))
				func(x, (y - 1))
				func(x, (y + 1))
				func((x + 1), (y - 1))
				func((x + 1), y)
				func((x + 1), (y + 1))
			}
			var changedList = (new Array(18)), idx
			for (var i = 0; i < 18; i++) {
				changedList[i] = { x: undefined, y: undefined }
			}
			function reverseStones(gameTree, x, y) {
				var board = gameTree.board, nt
				function reverseOneDirection(dirX, dirY) {
					var lx = (x + dirX), ly = (y + dirY), c = 0, stone
					while ((lx >= 0) && (ly >= 0) && (lx < 8) && (ly < 8)) {
						stone = board[(8 * lx) + ly]
						if (stone & EXIST) {
							if ((stone & COLOR) != gameTree.color) {
								lx += dirX
								ly += dirY
								c++
								continue
							} else {
								if (c > 0) {
									if (idx == 0) {
										nt = getGameTree(x, y, (1 - gameTree.color), board)
										board = nt.board
										board[(8 * x) + y] = (gameTree.color + EXIST)
									}
									do {
										c--
										lx -= dirX
										ly -= dirY
										board[(8 * lx) + ly] += ((2 * gameTree.color) - COLOR)
										changedList[idx].x = lx
										changedList[idx].y = ly
										idx++
									} while (c > 0)
								}
							}
						}
						break
					}
				}
				idx = 0
				around(reverseOneDirection, 0, 0)
				return nt
			}
			GameTree.prototype.noMove = function() {
				return getGameTree(8, 8, (1 - this.color), this.board)
			}
			var cellList = (new Array(64))
			for (let x = 0; x < 8; x++) {
				for (let y = 0; y < 8; y++) {
					cellList[(8 * x) + y] = { x: x, y: y }
				}
			}
			GameTree.prototype.makeList = function() {
				if (!this.list) {
					this.list = []
				} else if (this.list.length > 0) {
					return
				}
				for (var i = 0; i < 64; i++) {
					if (this.board[i] == EDGE) {
						this.list.push(cellList[i])
					}
				}
				if (this.list.length == 0) {
					this.list.push(this.noMove())
				}
			}
			function forceMove(gameTree, x, y) {
				var board
				function lowCostStabilize(x, y) {
					var color
					function checkTwoDirection(dirX, dirY, flag) {
						var lx = (x + dirX), ly = (y + dirY), stone, state = false
						if ((lx >= 0) && (ly >= 0) && (lx < 8) && (ly < 8)) {
							stone = board[(8 * lx) + ly]
							if ((stone & 62) == 62) { // (EXIST & STABLE)
								if ((stone & COLOR) == color) {
									return true
								}
							} else {
								state = true
							}
							lx = (x - dirX)
							ly = (y - dirY)
							if ((lx >= 0) && (ly >= 0) && (lx < 8) && (ly < 8)) {
								stone = board[(8 * lx) + ly]
								if ((stone & 62) == 62) {
									if (state) {
										return ((stone & COLOR) == color)
									}
								} else {
									return false
								}
							}
						}
						board[(8 * x) + y] |= flag
						return true
					}
					if ((x >= 0) && (y >= 0) && (x < 8) && (y < 8)) {
						var stone = board[(8 * x) + y]
						if ((stone & EXIST) && ((stone & STABLE) != STABLE)) {
							color = (stone & COLOR)
							if (((stone & STABLE_0) || checkTwoDirection(1, 0, STABLE_0))
									&& ((stone & STABLE_45) || checkTwoDirection(1, 1, STABLE_45))
									&& ((stone & STABLE_90) || checkTwoDirection(0, 1, STABLE_90))
									&& ((stone & STABLE_135) || checkTwoDirection(-1, 1, STABLE_135))) {
								board[(8 * x) + y] |= STABLE
								around(lowCostStabilize, x, y)
							}
						}
					}
				}
				function highCostStabilize(x, y) {
					function checkTwoDirection(dirX, dirY, flag, first) {
						var lx = (x + dirX), ly = (y + dirY), c = 0
						while ((lx >= 0) && (ly >= 0) && (lx < 8) && (ly < 8)) {
							if (board[(8 * lx) + ly] & EXIST) {
								lx += dirX
								ly += dirY
								c++
							} else {
								return false
							}
						}
						if (first) {
							if (checkTwoDirection((- dirX), (- dirY), flag, false)) {
								board[(8 * x) + y] |= flag
							} else {
								return false
							}
						}
						while (c > 0) {
							c--
							lx -= dirX
							ly -= dirY
							if (!(board[(8 * lx) + ly] & flag)) {
								board[(8 * lx) + ly] += flag
								if ((board[(8 * lx) + ly] & STABLE) == STABLE) {
									around(lowCostStabilize, lx, ly)
								} else {
									lowCostStabilize(lx, ly)
								}
							}
						}
						return true
					}
					checkTwoDirection(1, 0, STABLE_0, true)
					checkTwoDirection(1, 1, STABLE_45, true)
					checkTwoDirection(0, 1, STABLE_90, true)
					checkTwoDirection(-1, 1, STABLE_135, true)
					if ((board[(8 * x) + y] & STABLE) == STABLE) {
						around(lowCostStabilize, x, y)
					} else {
						lowCostStabilize(x, y)
					}
				}
				var nt = reverseStones(gameTree, x, y)
				if (idx > 0) {
					board = nt.board
					around(function(x, y) {
						if ((x >= 0) && (y >= 0) && (x < 8) && (y < 8)
								&& (board[(8 * x) + y] == 0)) {
							board[(8 * x) + y] = EDGE
						}
					}, x, y)
					highCostStabilize(x, y)
					var cell
					while (idx > 0) {
						idx--
						cell = changedList[idx]
						lowCostStabilize(cell.x, cell.y)
					}
				}
				return nt
			}
			GameTree.prototype.getMove = function(i) {
				var move = this.list[i]
				if (!move.board) {
					move = forceMove(this, move.x, move.y)
					if (move) {
						this.list[i] = move
					} else {
						this.list.splice(i, 1)
						if (this.list.length == 0) {
							move = this.noMove()
							this.list.push(move)
						}
					}
				}
				return move
			}

			// Drawing
			var canvas = document.querySelector("canvas"), ctx = canvas.getContext("2d")
			var colorBar = ["black", "white"]
			GameTree.prototype.draw = function() {
				var i, j, stone
				ctx.clearRect(0, 0, 400, 400)
				for (i = 0; i < 8; i++) {
					for (j = 0; j < 8; j++) {
						stone = this.board[(8 * i) + j]
						if (stone & EXIST) {
							/*
							if ((stone & STABLE) == STABLE) {
								ctx.fillStyle = "red"
								ctx.fillRect((i * 50), (j * 50), 50, 50)
							}
							*/
							ctx.fillStyle = colorBar[stone & COLOR]
							ctx.beginPath()
							ctx.arc(((i * 50) + 25), ((j * 50) + 25), 23, 0, (2 * Math.PI))
							ctx.closePath()
							ctx.fill()
						}
					}
				}
			}

			// AI
			var scoreTable = [
				71, -12,  -6,   0,   0,  -6, -12,  71,
			 -12, -16, -12, -13, -13, -12, -16, -12,
				-6, -12,  -7,  -1,  -1,  -7, -12,  -6,
				 0, -13,  -1,  -2,  -2,  -1, -13,   0,
				 0, -13,  -1,  -2,  -2,  -1, -13,   0,
				-6, -12,  -7,  -1,  -1,  -7, -12,  -6,
			 -12, -16, -12, -13, -13, -12, -16, -12,
				71, -12,  -6,   0,   0,  -6, -12,  71
			], stableScore = 71, calcTimes, $depth$ = 2
			function calcScore(gameTree) {
				calcTimes++
				var sum = 0, stone
				for (var i = 0; i < 64; i++) {
					stone = gameTree.board[i]
					if (stone & EXIST) {
						if ((stone & STABLE) != STABLE) {
							if ((stone & COLOR) == gameTree.color) {
								sum -= scoreTable[i]
							} else {
								sum += scoreTable[i]
							}
						} else {
							if ((stone & COLOR) == gameTree.color) {
								sum -= stableScore
							} else {
								sum += stableScore
							}
						}
					}
				}
				return sum
			}
			function countStone(board) {
				var c = 0;
				for (var i = 0; i < 64; i++) {
					if (board[i] & EXIST) {
						c++
					}
				}
				return c
			}
			function ssbaMain(gameTree, depth, beta) {
				gameTree.makeList()
				var i = gameTree.list.length, max = (- Infinity), score, move
				do {
					i--
					move = gameTree.getMove(i)
					if (move) {
						score = ((depth == 0)
							? calcScore(move)
							: ssbaMain(move, (depth - 1), (- max)))
						if (score > max) {
							max = score
							gameTree.list.splice(i, 1)
							gameTree.list.push(move)
							if (max >= beta) {
								break
							}
						}
					}
				} while (i > 0)
				return (- max)
			}
			function setStoneByAI(gameTree, depth) {
				var count = countStone(gameTree.board), next, start, spend, score
				calcTimes = 0
				start = Date.now()
				if ((count + depth) < 64) {
					for (;;) {
						score = (- ssbaMain(gameTree, depth, Infinity))
						spend = (Date.now() - start)
						console.log(`${count}, ${depth}, ${spend}, ${calcTimes}, ${score}, ${gameTree.list.length}`)
						if ((calcTimes < 10000) && ((count + depth) < 63)) {
							depth++
						} else {
							break
						}
					}
					if (calcTimes < 100000) {
						depth++
					} else {
						next = gameTree.list.pop()
						free(gameTree)
						$depth$ = depth
						return next
					}
				} else {
					depth = (64 - count)
					gameTree.makeList()
				}
				var move, max = (- Infinity)
				while (gameTree.list.length > 0) {
					move = gameTree.list.pop()
					if (!move.board) {
						move = forceMove(gameTree, move.x, move.y)
						if (!move) {
							continue
						}
					}
					score = ((depth == 0)
						? calcScore(move)
						: ssbaMain(move, (depth - 1), (- max)))
					if (score > max) {
						if (next) {
							free(next)
						}
						max = score
						next = move
					} else {
						free(move)
					}
				}
				if (!next) {
					next = gameTree.noMove()
				}
				spend = (Date.now() - start)
				console.log(`${count}, ${depth}, ${spend}, ${calcTimes}, ${max}`)
				GameTree.pool.push(gameTree)
				$depth$ = depth
				return next
			}

			// Interface
			function setStoneByHuman(gameTree, x, y) {
				gameTree.makeList()
				var move, i = gameTree.list.length
				while (i > 0) {
					i--
					move = gameTree.getMove(i)
					if (move && (((move.x == x) && (move.y == y)) || (move.x == 8))) {
						gameTree.list.splice(i, 1)
						if (gameTree.list.length > 0) {
							gameTree.list.forEach(free)
							gameTree.list.length = 0
						}
						GameTree.log.push(gameTree)
						return move
					}
				}
			}
			var $gameTree$ = initialGameTree()
			$gameTree$.draw()
			canvas.addEventListener("click", function(e) {
				var res = setStoneByHuman($gameTree$, Math.floor(e.x * 0.02), Math.floor(e.y * 0.02))
				if (res) {
					$gameTree$ = setStoneByAI(res, (($depth$ >= 2) ? ($depth$ - 2) : 0))
					$gameTree$.draw()
				}
			})
			document.getElementById("undo").addEventListener("click", function() {
				var prev = GameTree.log.pop()
				if (prev) {
					free($gameTree$)
					$gameTree$ = prev
					$depth$ = 2
					prev.draw()
				}
			})
			var userColor = document.getElementById("user-color")
			document.getElementById("reset").addEventListener("click", function() {
				free($gameTree$)
				if (GameTree.log.length > 0) {
					GameTree.log.forEach(free)
					GameTree.log.length = 0
				}
				$gameTree$ = initialGameTree()
				if (window.confirm("Do you use black?")) {
					userColor.textContent = "Black"
					$depth$ = 2
				} else {
					$gameTree$ = setStoneByAI($gameTree$, 1)
					userColor.textContent = "White"
				}
				$gameTree$.draw()
			})
			document.getElementById("gc").addEventListener("click", function() {
				GameTree.pool = []
			})
			console.log("stones, ply depth, time(ms), calcTimes, score[, moves]")
		</script>
	</body>
</html>
